from __future__ import print_function

import base64
import re
from xml.etree import ElementTree

import requests
from bs4 import BeautifulSoup
from fontTools import ttx

URL = "https://hidden-island-93990.squarectf.com/ea6c95c6d0ff24545cad"

# Fetch HTML from the page and get the base64-encoded TTF
res = requests.get(URL)
soup = BeautifulSoup(res.text, "html.parser")

ttf = re.findall(r"base64,([a-zA-Z0-9\/+=]*)", res.text)[0]
ttf = base64.decodestring(ttf)

# Save TTF to file
with open('font.ttf', 'w') as f:
    f.write(ttf)

# Dump the TTX from the TTF file using fontTools
ttx.ttDump('font.ttf', 'font.ttx', ttx.Options([], 1))
tree = ElementTree.parse('font.ttx').getroot()

# Map to values of the TTGlyph attributes from a TTX file mapped by hand
ttglyph_mapping = {
    "0": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 585,
        "yMax": 660,
    },
    "1": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 311,
        "yMax": 673,
    },
    "2": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 497,
        "yMax": 704,
    },
    "3": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 548,
        "yMax": 684,
    },
    "4": {
        "xMin": 0,
        "yMin": -3,
        "xMax": 576,
        "yMax": 690,
    },
    "5": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 531,
        "yMax": 690,
    },
    "6": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 544,
        "yMax": 679,
    },
    "7": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 510,
        "yMax": 696,
    },
    "8": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 569,
        "yMax": 689,
    },
    "9": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 561,
        "yMax": 689,
    },
    "+": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 495,
        "yMax": 519,
    },
    "-": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 465,
        "yMax": 347,
    },
    "*": {
        "xMin": 0,
        "yMin": 0,
        "xMax": 444,
        "yMax": 481,
    },

    # Parentheses use the first child of <pt>, because their attributes are identical
    "(": {
        "x": 239,
        "y": -127,
        "on": 1,
    },
    ")": {
        "x": 61,
        "y": -119,
        "on": 1,
    },
}


def compare_attrib(a, b):
    if "xMin" in a and "xMin" in b:
        return a['xMin'] == b['xMin'] and a['xMax'] == b['xMax'] and a['yMin'] == b['yMin'] and a['yMax'] == b['yMax']

    if "x" in a and "x" in b:
        return a['x'] == b['x'] and a['y'] == b['y'] and a['on'] == b['on']

    return False


# Find the mapping of glyphname (e.g. glyph00001) to code (e.g. 0x41, corresponding to 'A')
char_mapping = {}
for mapping in tree.find("cmap").find("cmap_format_4").findall("map"):
    char_mapping[mapping.attrib['name']] = chr(int(mapping.attrib['code'], base=16))

# Find the mapping of glyphs (by the pixel/vector information) to actual equation character
eqn_mapping = {}
glyf = tree.find("glyf")
for ttglyph in glyf.findall("TTGlyph"):
    attrib = ttglyph.attrib

    name = attrib['name']
    del attrib['name']
    if not attrib:
        continue

    # Check if parens
    if attrib['xMax'] == '290':
        attrib = ttglyph.find("contour").find("pt").attrib

    for k in attrib:
        attrib[k] = int(attrib[k])

    char = None
    for k, v in ttglyph_mapping.items():
        if compare_attrib(attrib, v):
            char = k
            break

    if not char:
        print("[!] Cannot map character: %s" % attrib)

    eqn_mapping[char] = char_mapping[name]

# Get the encoded equation text
eqn = soup.find("p").get_text()

# Map each character from the encoded letter to the actual equation character
reverse_eqn_mapping = {}
for char, letter in eqn_mapping.items():
    eqn = eqn.replace(letter, char)

print('[*] Equation:', eqn)

# Evalute answer
answer = eval(eqn)
print('[*] Evaluated answer:', answer)

# Submit answer
print('[*] Submitting answer...')
token = soup.find("input")['value']
res = requests.post(URL, data={'token': token, 'answer': answer})

# Get response text and flag
soup = BeautifulSoup(res.text, "html.parser")
text = soup.get_text("\n")
print("[*] Response text:\n")
print(text)
print()

flag = re.findall(r"flag-[0-9a-zA-Z]*", text)[0]
print('[*] Flag:', flag)
