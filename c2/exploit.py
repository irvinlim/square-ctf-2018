"""
C2: Flipping bits
=================

GCD(e1, e2) = 1
=> e1s1 * e2s2 = 1, for some s1, s2

c1^s1 * c2^s2 mod N
= (m^e1)^s1 * (m^e2)^s2 mod N
= m^(e1s1+e2s2) mod N
= m mod N

Hence, find s1 and s2 using Extended Euclidean Algorithm.

Adapted from https://github.com/PequalsNP-team/pequalsnp-team.github.io/blob/master/assets/CodeBlue2017/common_modulus.py
"""

from __future__ import print_function

from libnum import invmod, n2s, xgcd


def common_modulus(e1, e2, c1, c2, N):
    # Extended Euclidean algorithm
    a, b, d = xgcd(e1, e2)

    # Invert negative factor
    if b < 0:
        c2 = invmod(c2, N)
        b = -b
    if a < 0:
        c1 = invmod(c1, N)
        a = -a

    # Get the message (c1^a * c2^b) % N
    m = (pow(c1, a, N) * pow(c2, b, N)) % N
    return [m, a, b, d]


ct1 = 13981765388145083997703333682243956434148306954774120760845671024723583618341148528952063316653588928138430524040717841543528568326674293677228449651281422762216853098529425814740156575513620513245005576508982103360592761380293006244528169193632346512170599896471850340765607466109228426538780591853882736654
ct2 = 79459949016924442856959059325390894723232586275925931898929445938338123216278271333902062872565058205136627757713051954083968874644581902371182266588247653857616029881453100387797111559677392017415298580136496204898016797180386402171968931958365160589774450964944023720256848731202333789801071962338635072065
e1 = 13
e2 = 15
modulus = 103109065902334620226101162008793963504256027939117020091876799039690801944735604259018655534860183205031069083254290258577291605287053538752280231959857465853228851714786887294961873006234153079187216285516823832102424110934062954272346111907571393964363630079343598511602013316604641904852018969178919051627

m, _, _, d = common_modulus(e1, e2, ct1, ct2, modulus)

flag = n2s(m)
print(flag)
